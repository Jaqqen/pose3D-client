{"version":3,"sources":["static/img/locals/dURRLkVfHr7ZRqTSHeHTEj-1366-80.jpg","components/pose/PoseCam.jsx","components/pose/PoseHandler.js","components/pose/PoseCanvas.jsx","shared/ClassName.js","components/pose/PoseImg.jsx","components/pose/PoseMain.jsx","components/startpage/StartPageMain.jsx","components/voice/VoiceHandler.js","shared/IdConstants.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","PoseCam","props","setSrcReferenceInPoseMain","bind","webcamRef","React","createRef","this","getVideoSrcOnPlay","webcamVideo","current","video","addEventListener","height","clientHeight","Fragment","ref","audio","width","screenshotFormat","screenshotQuality","Component","getPosenetModel","a","posenet","architecture","outputStride","inputResolution","quantBytes","estimatePoseOnImage","poseNet","imageElement","Promise","resolve","estimateSinglePose","flipHorizontal","maxDetections","scoreThreshold","nmsRadius","PoseCanvas","state","_srcRef","srcRef","_posenetModel","captureVideo","drawGrid","drawJoint","drawJoints","drawJointByPart","getPoseCoordinates","setDimensions","canvasRef","srcType","ctx","getContext","dimensions","poseCoordinates","onplay","step","coordinates","clearRect","requestAnimationFrame","keypoints","forEach","keypoint","score","position","x","y","part","jointPart","color","wholeValue","floatValue","Math","trunc","ceil","floor","beginPath","arc","PI","fillStyle","fill","lineWidth","strokeStyle","stroke","context","w","h","moveTo","lineTo","className","PoseImg","imageRef","getImageSrcOnLoad","onLoad","alt","id","style","maxHeight","src","require","PoseMain","container","hasImageSrcLoaded","hasVideoSrcLoaded","srcPanelIdentifier","getPoseCanvas","getSrcPanel","srcContainerRef","posenetModel","setState","getPoseMainContentPanel","StartPageMain","autoFocus","onClick","renderMainAppPanel","VoiceHandler","recognition","window","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","lang","start","registeredSpeechRecogAlternatives","currentSpeechRecogSession","isError","setIsError","isErrorValue","useEffect","onstart","console","log","onresult","eventResult","_recogObjectKey","_speechRecogFirstAlternative","results","key","Object","keys","speechRecogFirstAlternative","undefined","onend","info","length","onerror","eventError","error","App","initState","hasMainAppStarted","startWebcam","confirm","getContentPanel","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.739d3007.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/dURRLkVfHr7ZRqTSHeHTEj-1366-80.95c13657.jpg\";","import React, { Component } from 'react'\nimport Webcam from 'react-webcam';\n\nexport default class PoseCam extends Component {\n    constructor(props) {\n        super(props);\n\n        //? bindings\n        this.setSrcReferenceInPoseMain = this.setSrcReferenceInPoseMain.bind(this);\n\n        //? references\n        this.webcamRef = React.createRef();\n    }\n\n    componentDidMount() {\n        this.setSrcReferenceInPoseMain();\n    }\n\n    setSrcReferenceInPoseMain() {\n        const { getVideoSrcOnPlay } = this.props\n\n        const webcamVideo = this.webcamRef.current.video;\n\n        webcamVideo.addEventListener('loadedmetadata', () => {\n            webcamVideo.height = webcamVideo.clientHeight;\n            getVideoSrcOnPlay(webcamVideo);\n        });\n    }\n\n    render() {\n\n        return (\n            <React.Fragment>\n                <Webcam\n                    ref={this.webcamRef}\n                    audio={false}\n                    width={700}\n                    screenshotFormat='image/jpeg'\n                    screenshotQuality={1}\n                />\n            </React.Fragment>\n        );\n    }\n}\n","import * as posenet from \"@tensorflow-models/posenet\";\n\nexport const getPosenetModel = async () => {\n    return await posenet.load({\n        architecture: 'ResNet50',\n        outputStride: 32,\n        inputResolution: { width: 257, height: 200 },\n        quantBytes: 2,\n    });\n};\n\nexport let estimatePoseOnImage = (poseNet, imageElement) => {\n    const p = new Promise((resolve) => {\n        resolve(\n            poseNet.estimateSinglePose(imageElement, {\n                flipHorizontal: false,\n                maxDetections: 5,\n                scoreThreshold: 0.1,\n                nmsRadius: 20,\n            })\n        );\n    });\n\n\n    return p;\n};","import React, { Component } from 'react';\nimport { estimatePoseOnImage } from 'components/pose/PoseHandler';\nimport * as CLASSNAME from 'shared/ClassName.js';\n\nexport default class PoseCanvas extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            _srcRef: props.srcRef,\n            _posenetModel: props._posenetModel,\n        };\n\n        //? bindings\n        this.captureVideo = this.captureVideo.bind(this);\n        this.drawGrid = this.drawGrid.bind(this);\n        this.drawJoint = this.drawJoint.bind(this);\n        this.drawJoints = this.drawJoints.bind(this);\n        this.drawJointByPart = this.drawJointByPart.bind(this);\n        this.getPoseCoordinates = this.getPoseCoordinates.bind(this);\n        this.setDimensions = this.setDimensions.bind(this);\n        \n        //? references\n        this.canvasRef = React.createRef();\n    }\n\n    async componentDidMount() {\n        const { srcType } = this.props;\n\n        const ctx = this.canvasRef.current.getContext(\"2d\");\n\n        //? sets dimensions to src dimensions\n        const dimensions = this.setDimensions();\n\n        //? draws grid for tests/check-ups - OPTIONAL\n        // this.drawGrid(ctx);\n\n        //? get coordinates\n        if (srcType === 'image') {\n            const poseCoordinates = await this.getPoseCoordinates();\n            this.drawJoints(poseCoordinates, ctx);\n        }\n        if (srcType === 'video') {\n            this.captureVideo(ctx, dimensions);\n        }\n    }\n\n    setDimensions() {\n        const { _srcRef } = this.state;\n\n        const width = _srcRef.width;\n        const height = _srcRef.height;\n\n        this.canvasRef.current.width = width;\n        this.canvasRef.current.height = height;\n\n        return {\n            height: height,\n            width: width,\n        };\n    }\n\n    captureVideo(ctx, dimensions) {\n        const { _posenetModel, _srcRef } = this.state;\n\n        _srcRef.onplay = () => {\n            const step = async () => {\n                let coordinates = await estimatePoseOnImage(_posenetModel, _srcRef);\n                ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n                this.drawJoints(coordinates, ctx)\n                requestAnimationFrame(step);\n            };\n            requestAnimationFrame(step);\n        };\n    }\n\n    async getPoseCoordinates() {\n        const { _posenetModel, _srcRef } = this.state;\n\n        let coordinates = await estimatePoseOnImage(_posenetModel, _srcRef);\n        return coordinates;\n    }\n\n    drawJoints(coordinates, ctx) {\n        let keypoints = coordinates.keypoints;\n\n        keypoints.forEach((keypoint) => {\n            if (keypoint.score >= 0.5) {\n                const { x, y } = keypoint.position;\n\n                this.drawJointByPart(x, y, keypoint.part, ctx);\n            }\n        });\n    }\n\n    drawJointByPart(x, y, jointPart, ctx) {\n        if (jointPart === 'nose') {\n            this.drawJoint(x, y, 'red', ctx);\n        } else if (jointPart === 'leftEye' || jointPart === 'rightEye') {\n            this.drawJoint(x, y, 'blue', ctx);\n        } else if (jointPart === 'leftEar' || jointPart === 'rightEar') {\n            this.drawJoint(x, y, 'green', ctx);\n        } else if (jointPart === 'leftShoulder' || jointPart === 'rightShoulder') {\n            this.drawJoint(x, y, 'orange', ctx);\n        } else if (jointPart === 'leftElbow' || jointPart === 'rightElbow') {\n            this.drawJoint(x, y, 'violet', ctx);\n        } else if (jointPart === 'leftWrist' || jointPart === 'rightWrist') {\n            this.drawJoint(x, y, 'magenta', ctx);\n        } else if (jointPart === 'leftHip' || jointPart === 'rightHip') {\n            this.drawJoint(x, y, 'black', ctx);\n        } else if (jointPart === 'leftKnee' || jointPart === 'rightKnee') {\n            this.drawJoint(x, y, 'yellow', ctx);\n        } else if (jointPart === 'leftAnkle' || jointPart === 'rightAnkle') {\n            this.drawJoint(x, y, 'cyan', ctx);\n        }\n    }\n\n    drawJoint(x, y, color, ctx) {\n        const wholeValue = (floatValue) => {\n            return (floatValue % Math.trunc(floatValue) > 0.5) \n                ? Math.ceil(floatValue)\n                : Math.floor(floatValue);\n        };\n\n        ctx.beginPath();\n        ctx.arc(wholeValue(x), wholeValue(y), 6, 0, 2*Math.PI, false);\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = '#ffffff';\n        ctx.stroke();\n    };\n\n    drawGrid(context) {\n        const { _srcRef } = this.state\n\n        const w = _srcRef.width;\n        const h = _srcRef.height;\n\n        //? vertical lines\n        for (let x = 0; x <= w; x += 10) {\n            context.moveTo(x, 0);\n            context.lineTo(x, h);\n        }\n\n        //? horizontal lines\n        for (let y = 0; y <= h; y += 10) {\n            context.moveTo(0, y);\n            context.lineTo(w, y);\n        }\n\n        context.strokeStyle = \"black\";\n        context.stroke();\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <div className={CLASSNAME.canvasContainer}>\n                    <canvas\n                        ref={this.canvasRef}\n                        width={100}\n                        height={100}\n                    />\n                </div>\n            </React.Fragment>\n        )\n    }\n}\n","export const canvasContainer = \"canvas-container\";\nexport const poseMainContainer = \"posemain-container\";\nexport const vmodelMainContainer = \"vmodelmain-container\";\nexport const startpageMainContainer = \"startpagemain-container\";\nexport const startpageMainButtonContainer = \"startpagemain-button-container\";","import React, { Component } from 'react'\n\nexport default class PoseImg extends Component {\n    constructor(props) {\n        super(props);\n        //? bindings\n        this.setSrcReferenceInPoseMain = this.setSrcReferenceInPoseMain.bind(this);\n\n        //? references\n        this.imageRef = React.createRef();\n    }\n\n    setSrcReferenceInPoseMain() {\n        const { getImageSrcOnLoad } = this.props\n\n        getImageSrcOnLoad(this.imageRef.current);\n    }\n\n    render() {\n\n        return (\n            <React.Fragment>\n                <img\n                    onLoad={this.setSrcReferenceInPoseMain}\n                    ref={this.imageRef}\n                    alt={\"obama\"}\n                    id={\"xyz2\"}\n                    style= {{ maxHeight:'500px', }}\n                    src={require(\"static/img//locals/dURRLkVfHr7ZRqTSHeHTEj-1366-80.jpg\")}\n                />\n            </React.Fragment>\n        );\n    }\n}\n","import React, { Component } from 'react';\nimport PoseCam from './PoseCam';\nimport { getPosenetModel } from \"components/pose/PoseHandler\";\nimport * as CLASSNAME from 'shared/ClassName';\nimport PoseCanvas from 'components/pose/PoseCanvas';\nimport PoseImg from 'components/pose/PoseImg';\n\nexport default class PoseMain extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            container: {\n                height: 0,\n                width: 0,\n            },\n            _posenetModel: null,\n            hasImageSrcLoaded: false,\n            hasVideoSrcLoaded: false,\n            _srcRef: null,\n            srcPanelIdentifier: 'video',\n        };\n\n        //? bindings\n        this.getPosenetModel = this.getPosenetModel.bind(this);\n        this.getImageSrcOnLoad = this.getImageSrcOnLoad.bind(this);\n        this.getVideoSrcOnPlay = this.getVideoSrcOnPlay.bind(this);\n        this.getPoseCanvas = this.getPoseCanvas.bind(this);\n        this.getSrcPanel = this.getSrcPanel.bind(this);\n\n        //? references\n        this.srcContainerRef = React.createRef();\n    }\n\n    componentDidMount() {\n        this.getPosenetModel();\n    }\n\n    async getPosenetModel() {\n        const posenetModel = await getPosenetModel();\n\n        this.setState({ _posenetModel: posenetModel, });\n    }\n\n    getImageSrcOnLoad(srcRef) {\n        const { container } = this.state\n\n        this.setState({\n            container: {\n                ...container,\n                height: srcRef.height,\n                width: srcRef.width,\n            },\n            hasImageSrcLoaded: true,\n            _srcRef: srcRef,\n        });\n    }\n\n    getVideoSrcOnPlay(srcRef) {\n        const { container } = this.state\n\n        this.setState({\n            container: {\n                ...container,\n                height: srcRef.height,\n                width: srcRef.width,\n            },\n            hasVideoSrcLoaded: true,\n            _srcRef: srcRef,\n        });\n    }\n\n    getPoseCanvas() {\n        const { hasImageSrcLoaded, hasVideoSrcLoaded, _posenetModel, _srcRef } = this.state;\n\n        let srcType = null;\n        if (hasVideoSrcLoaded) srcType = 'video';\n        if (hasImageSrcLoaded) srcType = 'image';\n\n        if (srcType !== null) {\n            return (\n                <PoseCanvas\n                    srcType={srcType}\n                    srcRef={_srcRef}\n                    _posenetModel={_posenetModel}\n                />\n            );\n        }\n        return null;\n    }\n\n    getSrcPanel() {\n        const { srcPanelIdentifier } = this.state;\n\n        if (srcPanelIdentifier === 'image') {\n            return (\n                <PoseImg\n                    getImageSrcOnLoad={this.getImageSrcOnLoad}\n                />\n            );\n        } else if (srcPanelIdentifier === 'video') {\n            return (\n                <PoseCam\n                    getVideoSrcOnPlay={this.getVideoSrcOnPlay}\n                />\n            );\n        } else {\n            return null;\n        }\n    }\n\n    getPoseMainContentPanel() {\n        const { _posenetModel, container } = this.state;\n\n        if (_posenetModel) {\n            return (\n                <div\n                    style={{ height: container.height + 'px', width: container.width + 'px'}}\n                    className={CLASSNAME.poseMainContainer}\n                >\n                    {this.getPoseCanvas()}\n                    {this.getSrcPanel()}\n                </div>\n            )\n        }\n\n        return \".-`´-. Loading... .-`´-.\";\n    }\n\n    render() { return this.getPoseMainContentPanel(); }\n}","import React, { Component } from 'react'\nimport * as CLASSNAME from 'shared/ClassName';\n\nexport default class StartPageMain extends Component {\n    render() {\n        return (\n            <div className={CLASSNAME.startpageMainContainer}>\n                <h1> Welcome to Pose3D </h1>\n                <p>\n                    Please follow the instructions in the following page after clicking on <b>Start</b>\n                </p>\n                <div className={CLASSNAME.startpageMainButtonContainer}>\n                    <button autoFocus={true} onClick={this.props.renderMainAppPanel} >Start</button>\n                </div>\n            </div>\n        )\n    }\n}\n"," \nimport React, { useEffect } from 'react'\nimport { voiceHanlder } from 'shared/IdConstants';\n\nexport default function VoiceHandler() {\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    const recognition = new SpeechRecognition();\n    recognition.continuous = true;\n    recognition.interimResults = false;\n    recognition.lang = \"en-US\";\n    recognition.start();\n\n    let registeredSpeechRecogAlternatives = {};\n    let currentSpeechRecogSession = 0;\n    let isError = false;\n\n    const setRegisteredSpeechRecogAlternatives = (_recogObjectKey, _speechRecogFirstAlternative) => {\n        registeredSpeechRecogAlternatives = {\n            ...registeredSpeechRecogAlternatives,\n            [currentSpeechRecogSession]: {\n                ...registeredSpeechRecogAlternatives[currentSpeechRecogSession],\n                [_recogObjectKey]: _speechRecogFirstAlternative\n            }\n        }\n    };\n\n    const setSpeechRecogSession = () => {\n        if (Object.keys(registeredSpeechRecogAlternatives[currentSpeechRecogSession]).length === 0) {\n            delete registeredSpeechRecogAlternatives[currentSpeechRecogSession];\n        }\n\n        if (isError) {\n            setIsError(false);\n        } else {\n            currentSpeechRecogSession = currentSpeechRecogSession + 1;\n        }\n\n        registeredSpeechRecogAlternatives = {\n            ...registeredSpeechRecogAlternatives,\n            [currentSpeechRecogSession]: {}\n        };\n\n        recognition.start();\n    };\n\n    const setIsError = (isErrorValue) => {\n        isError = isErrorValue;\n    }\n\n    useEffect(() => {\n        recognition.onstart = () => {\n            console.log('VoiceHandler has entered: ONSTART');\n        };\n\n        recognition.onresult = (eventResult) => {\n            const results = eventResult.results;\n            for (let key in Object.keys(results)) {\n                const speechRecogFirstAlternative = results[key][0];\n                if (speechRecogFirstAlternative !== null ||\n                    speechRecogFirstAlternative !== undefined) {\n                    setRegisteredSpeechRecogAlternatives(key, speechRecogFirstAlternative);\n                }\n            }\n            console.log(registeredSpeechRecogAlternatives);\n        };\n\n        recognition.onend = () => {\n            console.info('VOICE IS DYING....');\n            setSpeechRecogSession();\n        };\n\n        recognition.onerror = (eventError) => {\n            setIsError(true);\n            console.error(eventError);\n        };\n\n    })\n\n    return (\n        <span id={voiceHanlder}>V2E</span>\n    )\n}\n","export const voiceHanlder = \"voice-handler\";","import React, { Component } from 'react';\nimport 'App.css';\nimport PoseMain from \"components/pose/PoseMain\";\nimport StartPageMain from 'components/startpage/StartPageMain';\nimport VoiceHandler from 'components/voice/VoiceHandler';\n\nexport default class App extends Component {\n    constructor(props) {\n        super(props);\n        this.initState = {\n            hasMainAppStarted: false,\n        };\n        this.state = { ...this.initState };\n\n        this.renderMainAppPanel = this.renderMainAppPanel.bind(this);\n    }\n\n    renderMainAppPanel() {\n        const startWebcam = window.confirm(\"Enable Webcam to start tracking?\");\n        this.setState({ hasMainAppStarted: startWebcam, });\n    }\n\n    getContentPanel() {\n        const { hasMainAppStarted } = this.state;\n\n        if (hasMainAppStarted) {\n            return (\n                <div className=\"App\">\n                    <PoseMain />\n                    <VoiceHandler />\n                </div>\n            );\n        }\n\n        return <StartPageMain renderMainAppPanel={this.renderMainAppPanel} />;\n    }\n\n    render() { return this.getContentPanel(); }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <>\n    <App />\n  </>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}